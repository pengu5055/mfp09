"""
This file contains a wrapper class for the MPI wrapper class which will
collect statistics from the MPI nodes and plot them. The statistics
gathered are the time it took to solve the PDE. 
"""
from mpi4py import MPI
from mpi import MPI_Node
import numpy as np
from colocation import ColocationSolver
from spectral import SpectralSolver
import matplotlib.pyplot as plt
import socket
from typing import Tuple, Callable, List, Iterable
from string import Template
import subprocess


class GatherStatistics:
    def __init__(self,
                 rank_range: Tuple[int, int],
                 sample_size: int,
                 step: int = 1,
                 ) -> None:
        """
        Initialize the statistics gatherer.
        """
        # Init statistics
        self.rank_range = rank_range
        self.sample_size = sample_size
        self.fname = "temp_stat.py"
        self.step = step

    def _internal_function_timer(func: Callable):
        def wrapper(*args, **kwargs):
            import time
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(f"Function {func.__name__} took {end - start} seconds to run.")
            return result, start - end
        return wrapper

    def run(self):
        """
        Run the statistics gatherer. Which obtains time for solving the PDE
        for each rank.
        """
        # Generate core number range
        core_range = np.arange(self.rank_range[0], self.rank_range[1], self.step)

        # Generate code
        self._generate_code()

        # Iterate over core numbers
        times = []
        for core_count in core_range:
            intermediary = []
            print("-"*50)
            for _ in range(self.sample_size):
                cmd = f"mpiexec -n {core_count} python -m mpi4py {self.fname}"
                cmd_return = subprocess.run(cmd, shell=True, capture_output=True)
                print(cmd_return.stdout.decode("utf-8"))
                try:
                    # Get all numbers after @ until %. Ultra hacky.
                    result = cmd_return.stdout.decode().split("@")[1].split("%")[0]
                    intermediary.append(float(result))
                except ValueError:
                    intermediary.append("NaN")
            
            times.append(np.mean(intermediary))
            intermediary.clear()

        # Remove temporary files
        self._remove_temp_files()

        return core_range, times




    def _generate_code(self, fname: str = "temp_stat.py"):
        """
        Generate the code on which to run the statistics gatherer.
        """
        fname = self.fname
        template = Template("""
# Path: gatherstat.py
import numpy as np
from mpi import MPI_Node
from colocation import ColocationSolver
from spectral import SpectralSolver
                    
def initial_condition(x):
    return np.sin(2*np.pi*x*10)
# Solve for these points
t = np.linspace(0, 1, 1000)
# Solve for this grid range
x_range = (0, 1)
# Solve for this grid size
N = 1000
# Solve for this diffusion constant
D = 1e-5
# Initialize solver
solver = ColocationSolver(initial_condition, x_range, N, t, D)

node = MPI_Node(solver)
print(f"@{node.solve()[1]}%")
""")

        code = template.substitute()

        with open(fname, "w") as f:
            f.write(code)


    def _remove_temp_files(self):
        """
        Remove temporary files generated by the statistics gatherer.
        """
        import os
        os.remove(self.fname)